<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
  <title>Hallväder + Dagens text</title>
  <style>
    :root{
      --bg:#0f1115; --fg:#e8eaed; --muted:#a7b0bc; --card:#151922; --accent:#5aa7ff;
    }
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font:500 20px/1.4 system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      overflow:hidden;
    }
    .grid{
      display:grid; grid-template-columns:1.1fr 1.6fr; grid-auto-rows:100%;
      gap:20px; padding:24px; height:100vw; width:100vh;
      transform:rotate(90deg); transform-origin:left top; position:absolute; top:0; left:0;
    }
    @media (orientation:landscape){
      .grid{height:100vh; width:100vw; transform:none; position:static;}
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.06);
      border-radius:24px; padding:24px; box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    .weather{display:flex; flex-direction:column; height:90%}
    .row{display:flex; align-items:baseline; gap:16px; flex-wrap:wrap}
    .temp{font-size:80px; font-weight:700; letter-spacing:-2px}
    .badge{padding:6px 10px; border-radius:999px; background:#1b2230; color:var(--muted); font-size:14px}
    .muted{color:var(--muted)} .city{font-size:28px; font-weight:650} .big{font-size:18px}
    .stats{display:grid; grid-template-columns:repeat(3,1fr); gap:12px; margin-top:16px}
    .stat{background:var(--card); border-radius:16px; padding:14px; text-align:center}
    .footer{margin-top:auto; font-size:14px; color:var(--muted)}
    a{color:var(--accent); text-decoration:none}

    /* Dagens text */
    .dt-wrap{display:flex; flex-direction:column; height:90%;}
    .dt-content{
      background:var(--card); border-radius:16px; padding:18px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
      height:100%; overflow:auto;
    }
    .dt-content p { margin: 0 0 0.8em; }
  </style>
</head>
<body>
  <div class="grid">
    <!-- VÄDER -->
    <section class="card weather">
      <div class="row">
        <div class="city" id="city">–</div>
        <span class="badge" id="time">—</span>
      </div>
      <div class="row" style="align-items:center; margin-top:8px">
        <div class="temp" id="temp">–°</div>
        <div class="big" id="summary">Hämtar väder…</div>
      </div>
      <div class="stats">
        <div class="stat">Känns som<br><strong id="feels">–°</strong></div>
        <div class="stat">Vind<br><strong id="wind">– m/s</strong></div>
        <div class="stat">Nederbörd (1h)<br><strong id="precip">– mm</strong></div>
      </div>
    </section>

    <!-- DAGENS TEXT -->
    <section class="card dt-wrap">
      <div>
        <span id="dtStatus" class="muted">Laddar…</span>
      </div>
      <div id="dtContent" class="dt-content" aria-live="polite"></div>
    </section>
  </div>

<script>
/* === KONFIG === */
const CITY_NAME = "Örebro";
const TZ = "Europe/Stockholm";
const REFRESH_MS = 5 * 60 * 1000;

/* EPUB-plan: justera dessa två vid behov */
const OPF_PATH = 'es25_Z/OEBPS/content.opf';
const OEBPS_DIR = 'es25_Z/OEBPS/';
const PLAN_START_ID   = 'chapter6';        // första kapitlet i din plan
const PLAN_START_DATE = '2025-01-01';      // kalenderdatum när chapter5 ska visas
/* ========================== */

/* --- Open-Meteo väder --- */
const wmo = {
  0:"Klart",1:"Mest klart",2:"Växlande molnighet",3:"Mulet",
  45:"Dimma",48:"Isdimma",
  51:"Duggregn lätt",53:"Duggregn måttligt",55:"Duggregn kraftigt",
  56:"Underkylt duggregn lätt",57:"Underkylt duggregn kraftigt",
  61:"Regn lätt",63:"Regn",65:"Regn kraftigt",
  66:"Underkylt regn lätt",67:"Underkylt regn kraftigt",
  71:"Lätt snöfall",73:"Snöfall",75:"Kraftigt snöfall",
  80:"Skurar lätta",81:"Skurar",82:"Skurar kraftiga",
  85:"Snöbyar lätta",86:"Snöbyar kraftiga",
  95:"Åska",96:"Åska med hagel",99:"Kraftig åska med hagel"
};

const el = id => document.getElementById(id);

/* ---- VÄDER ---- */
async function geocodeCity(name){
  const u = new URL("https://geocoding-api.open-meteo.com/v1/search");
  u.searchParams.set("name", name);
  u.searchParams.set("count", 1);
  u.searchParams.set("language", "sv");
  const r = await fetch(u.href);
  const j = await r.json();
  if(!j.results || !j.results.length) throw new Error("Hittade inte plats");
  return j.results[0];
}
async function fetchWeather(lat, lon){
  const u = new URL("https://api.open-meteo.com/v1/forecast");
  u.searchParams.set("latitude", lat);
  u.searchParams.set("longitude", lon);
  u.searchParams.set("current", ["temperature_2m","apparent_temperature","weather_code","wind_speed_10m","precipitation"].join(","));
  u.searchParams.set("wind_speed_unit","ms");
  u.searchParams.set("timezone", TZ);
  const r = await fetch(u.href);
  return await r.json();
}
function formatTime(){
  const d = new Date();
  return d.toLocaleString("sv-SE", { hour:"2-digit", minute:"2-digit", weekday:"long" });
}
async function loadWeather(){
  try{
    el("city").textContent = CITY_NAME;
    el("time").textContent = formatTime();
    const place = await geocodeCity(CITY_NAME);
    const data  = await fetchWeather(place.latitude, place.longitude);
    const c = data.current;
    el("temp").textContent  = Math.round(c.temperature_2m) + "°";
    el("feels").textContent = Math.round(c.apparent_temperature) + "°";
    el("wind").textContent  = (Math.round(c.wind_speed_10m*10)/10) + " m/s";
    el("precip").textContent= (c.precipitation ?? 0) + " mm";
    el("summary").textContent = wmo[c.weather_code] || "—";
  }catch(err){
    el("summary").textContent = "Kunde inte hämta väder.";
    console.error(err);
  }
}

/* ---- EPUB / DAGENS TEXT ---- */

/* Helper: build a Date for local midnight (no time-of-day ambiguity) */
function localDate(y, m, d){
  const dt = new Date();
  dt.setFullYear(y, m - 1, d);
  dt.setHours(0,0,0,0);
  return dt;
}

/* Days between two local dates (ignores time-of-day) */
function daysBetweenLocal(a, b){
  const MS = 24*60*60*1000;
  const d1 = new Date(a.getFullYear(), a.getMonth(), a.getDate());
  const d2 = new Date(b.getFullYear(), b.getMonth(), b.getDate());
  return Math.floor((d2 - d1) / MS);
}

/* Today at local midnight */
function todayLocal(){
  const now = new Date();
  return new Date(now.getFullYear(), now.getMonth(), now.getDate());
}

function stripExtras(doc){
  // remove EPUB reference group(s) you identified
  const selectors = ['div[class="groupExt"]'];
  selectors.forEach(sel => doc.querySelectorAll(sel).forEach(n => n.remove()));
  doc.querySelectorAll('figcaption').forEach(n => n.remove());
  return doc;
}

async function loadChapterOfTheDay(){
  const status = el('dtStatus');
  const out    = el('dtContent');

  try{
    status.textContent = "Laddar…";

    // 1) Read OPF
    const resp = await fetch(OPF_PATH, { cache: "no-store" });
    if(!resp.ok) throw new Error("OPF saknas: " + resp.status);
    const xmlText = await resp.text();

    const parser = new DOMParser();
    const xml = parser.parseFromString(xmlText, 'application/xml');
    if (xml.querySelector('parsererror')) {
      throw new Error("XML parserfel: " + xml.querySelector('parsererror').textContent);
    }

    // 2) Collect chapter items
    const items = Array.from(xml.querySelectorAll('item[id^="chapter"]'))
      .map(el => ({
        id: el.getAttribute('id'),
        n: parseInt(el.getAttribute('id').replace('chapter',''), 10),
        href: el.getAttribute('href')
      }))
      .filter(x => Number.isFinite(x.n))
      .sort((a,b) => a.n - b.n);

    if (!items.length) throw new Error("Inga kapitel hittades i OPF.");

    // 3) Find the index of PLAN_START_ID
    const startIndex = items.findIndex(x => x.id === PLAN_START_ID);
    if (startIndex < 0) throw new Error("PLAN_START_ID saknas i OPF.");

    // 4) Compute days since PLAN_START_DATE (local)
    const [sy, sm, sd] = PLAN_START_DATE.split('-').map(Number);
    const base = localDate(sy, sm, sd);
    const today = todayLocal();
    const daysSince = daysBetweenLocal(base, today);

    // 5) Pick chapter: advance 'daysSince' from startIndex
    const idx = ((startIndex + (daysSince % items.length)) + items.length) % items.length;
    const chosen = items[idx];
    const chapterUrl = OEBPS_DIR + chosen.href;

    // 6) Fetch, parse, strip, show
    const ch = await fetch(chapterUrl, { cache: "no-store" });
    if(!ch.ok) throw new Error("Kunde inte läsa kapitel");
    const chapterHtml = await ch.text();

    const chapterDoc = new DOMParser().parseFromString(chapterHtml, 'text/html');
    stripExtras(chapterDoc);

    const container =
      chapterDoc.querySelector('main') ||
      chapterDoc.querySelector('article') ||
      chapterDoc.querySelector('section') ||
      chapterDoc.body;

    out.innerHTML = container ? container.innerHTML : chapterDoc.body.innerHTML;
    status.textContent = "";
  }catch(e){
    console.error(e);
    el('dtStatus').textContent = "Kunde inte läsa EPUB.";
    el('dtContent').textContent = "";
  }
}

/* ---- Enkla schemaläggare ---- */
function scheduleDaily(atHour=0, atMinute=10, fn){
  const now = new Date();
  const next = new Date();
  next.setHours(atHour, atMinute, 0, 0);
  if (next <= now) next.setDate(next.getDate() + 1);
  const delay = Math.max(next - now, 30*1000);
  setTimeout(() => { fn(); scheduleDaily(atHour, atMinute, fn); }, delay);
}

/* ---- START ---- */
loadWeather();
setInterval(()=>{ el("time").textContent = formatTime(); }, 30*1000);
setInterval(loadWeather, REFRESH_MS);

loadChapterOfTheDay();              // show now
scheduleDaily(0, 10, loadChapterOfTheDay); // refresh after midnight, 00:10
</script>
</body>
</html>
